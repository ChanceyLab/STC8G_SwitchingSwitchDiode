C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE STC8X_UART
OBJECT MODULE PLACED IN .\build\STC8x_UART.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\..\libraries\peripherals\STC8x\src\STC8x_UART.c LARGE OMF2 OPTIMIZE(9
                    -,SPEED) BROWSE INCDIR(..\..\libraries;..\..\libraries\core;..\..\libraries\core\register\STC8x;..\..\libraries\core\star
                    -tup\STC8x;..\..\libraries\drives;..\..\libraries\drives\KeyScan;..\..\libraries\peripherals;..\..\libraries\peripherals\
                    -STC8x\inc;..\..\libraries\peripherals\STC8x\src;..\..\libraries\components;..\..\libraries\components\TMT;..\..\librarie
                    -s\components\PrintfRed;..\..\libraries\components\PreDelay;.\main;.\application) DEBUG PRINT(.\build\STC8x_UART.lst) OBJ
                    -ECT(.\build\STC8x_UART.obj)

line level    source

   1          /*-----------------------------------------------------------------------
   2          |                            FILE DESCRIPTION                           |
   3          -----------------------------------------------------------------------*/
   4          /*----------------------------------------------------------------------
   5            - File name     : STC8x_UART.c
   6            - Author        : zeweni
   7            - Update date   : 2020.04.27
   8            -     Copyright(C)  : 2020-2021 zeweni. All rights reserved.
   9          -----------------------------------------------------------------------*/
  10          /*------------------------------------------------------------------------
  11          |                            COPYRIGHT NOTICE                            |
  12          ------------------------------------------------------------------------*/
  13          /*
  14           * Copyright (C) 2021, zeweni (17870070675@163.com)
  15          
  16           * This file is part of 8051 ELL low-layer libraries.
  17          
  18           * 8051 ELL low-layer libraries is free software: you can redistribute 
  19           * it and/or modify it under the terms of the Apache-2.0 License.
  20          
  21           * 8051 ELL low-layer libraries is distributed in the hope that it will 
  22           * be useful,but WITHOUT ANY WARRANTY; without even the implied warranty 
  23           * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  24           * Apache-2.0 License for more details.
  25          
  26           * You should have received a copy of the Apache-2.0 License.8051 ELL 
  27           * low-layer libraries. If not, see <http://www.apache.org/licenses/>.
  28          **/
  29          /*-----------------------------------------------------------------------
  30          |                               INCLUDES                                |
  31          -----------------------------------------------------------------------*/
  32          #include "STC8x_UART.h"
  33          
  34          /*-----------------------------------------------------------------------
  35          |                             DECLARATION                               |
  36          -----------------------------------------------------------------------*/
  37          
  38          /*--------------------------------------------------------
  39          | @Description: UART mode configure define function      |
  40          --------------------------------------------------------*/
  41          
  42          /**
  43           * @brief   ä¸²å£1å·¥ä½œæ¨¡å¼é€‰æ‹©å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°ƒç”¨ã€‚
  44           * @details Serial Port 1 mode of operation selects macro functions and is only called within this file.
  45          **/
  46          #define  UART1_MODE_CFG(mode)  do{SM0 = mode >> 1, SM1 = mode;}while(0)
  47          
  48          
  49          /**
  50           * @brief   ä¸²å£2å·¥ä½œæ¨¡å¼é€‰æ‹©å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°ƒç”¨ã€‚
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 2   

  51           * @details Serial Port 2 mode of operation selects macro functions and is only called within this file.
  52          **/
  53          #define  UART2_MODE_CFG(mode)  do{S2CON = (S2CON & 0x3F)|((mode & 0x02) << 6);}while(0)
  54          
  55          
  56          /**
  57           * @brief   ä¸²å£3å·¥ä½œæ¨¡å¼é€‰æ‹©å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°ƒç”¨ã€‚
  58           * @details Serial Port 3 mode of operation selects macro functions and is only called within this file.
  59          **/
  60          #define  UART3_MODE_CFG(mode)  do{S3CON = (S3CON & 0x3F)|((mode & 0x02) << 6);}while(0)
  61          
  62          
  63          /**
  64           * @brief   ä¸²å£4å·¥ä½œæ¨¡å¼é€‰æ‹©å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°ƒç”¨ã€‚
  65           * @details Serial Port 4 mode of operation selects macro functions and is only called within this file.
  66          **/
  67          #define  UART4_MODE_CFG(mode)  do{S4CON = (S4CON & 0x3F)|((mode & 0x02) << 6);}while(0)
  68          
  69          /*--------------------------------------------------------
  70          | @Description: UART Baud rate configure define function |
  71          --------------------------------------------------------*/
  72          
  73          /**
  74           * @brief     ä¸²å£1ç”¨å®šæ—¶å™¨1åšæ³¢ç‰¹ç‡å‘ç”Ÿå™¨è®¡ç®—æ³¢ç‰¹ç‡å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°ƒç”¨
             -ã€‚
  75           * @details   Serial port 1 uses timer 1 to do baud rate generator calculation baud rate macro function, 
  76           *            which is only called in this file.
  77           * @param[in] brtMode  æ³¢ç‰¹ç‡å‘ç”Ÿå™¨æ¨¡å¼ã€‚Baud rate generator mode.
  78           * @param[in] baudRate æ³¢ç‰¹ç‡ã€‚Baud rate.
  79          **/
  80          #define UART1_TIMER1_BRTMODE_CFG(brtMode,baudRate)                                      \
  81          do{                                                                                     \
  82              AUXR = (AUXR & 0xBF) | ( !brtMode << 6 );                                           \
  83              T1L = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(AUXR & 0x40)) + 1 )));       \
  84              T1H = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(AUXR & 0x40)) + 1 ))) >> 8;  \
  85          }while(0)
  86          
  87          #if  (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
              
                  /**
                   * @brief     ä¸²å£ç”¨å®šæ—¶å™¨2åšæ³¢ç‰¹ç‡å‘ç”Ÿå™¨è®¡ç®—æ³¢ç‰¹ç‡å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°ƒ
             -ç”¨ã€‚
                   * @details   Serial port uses timer 2 to do baud rate generator calculation baud rate macro function,
             - 
                   *            which is only called in this file.
                   * @param[in] brtMode  æ³¢ç‰¹ç‡å‘ç”Ÿå™¨æ¨¡å¼ã€‚Baud rate generator mode.
                   * @param[in] baudRate æ³¢ç‰¹ç‡ã€‚Baud rate.
                  **/
                      #define uartx_TIMER2_BRTMODE_CFG(brtMode,baudRate)                                     \
                  do{                                                                                    \
                          AUXR = (AUXR & 0xFB) | ( !brtMode << 2 );                                          \
                          T2L = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(AUXR & 0x04)) + 1 )));      \
                          T2H = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(AUXR & 0x04)) + 1 ))) >> 8; \
                      }while(0)
              
              
                  /**
                   * @brief     ä¸²å£3ç”¨å®šæ—¶å™¨3åšæ³¢ç‰¹ç‡å‘ç”Ÿå™¨è®¡ç®—æ³¢ç‰¹ç‡å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°
             -ƒç”¨ã€‚
                   * @details   Serial port 3 uses timer 3 to do baud rate generator calculation baud rate macro functio
             -n, 
                   *            which is only called in this file.
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 3   

                   * @param[in] brtMode  æ³¢ç‰¹ç‡å‘ç”Ÿå™¨æ¨¡å¼ã€‚Baud rate generator mode.
                   * @param[in] baudRate æ³¢ç‰¹ç‡ã€‚Baud rate.
                  **/
                      #define UART3_TIMER3_BRTMODE_CFG(brtMode,baudRate)                                      \
                  do{                                                                                     \
                          T4T3M = (T4T3M & 0xFD) | ( !brtMode << 1 );                                         \
                          T3L = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(T4T3M & 0x02)) + 1 )));      \
                          T3H = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(T4T3M & 0x02)) + 1 ))) >> 8; \
                      }while(0)
              
              
                  /**
                   * @brief     ä¸²å£4ç”¨å®šæ—¶å™¨4åšæ³¢ç‰¹ç‡å‘ç”Ÿå™¨è®¡ç®—æ³¢ç‰¹ç‡å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°
             -ƒç”¨ã€‚
                   * @details   Serial port 4 uses timer 4 to do baud rate generator calculation baud rate macro functio
             -n, 
                   *            which is only called in this file.
                   * @param[in] brtMode  æ³¢ç‰¹ç‡å‘ç”Ÿå™¨æ¨¡å¼ã€‚Baud rate generator mode.
                   * @param[in] baudRate æ³¢ç‰¹ç‡ã€‚Baud rate.
                  **/
                      #define UART4_TIMER4_BRTMODE_CFG(brtMode,baudRate)                                      \
                  do{                                                                                     \
                          T4T3M = (T4T3M & 0xDF) | ( !brtMode << 5 );                                         \
                          T4L = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(T4T3M & 0x20)) + 1 )));      \
                          T4H = (65536UL - sysClk_FRE / (baudRate * 4 * (11 * (!(T4T3M & 0x20)) + 1 ))) >> 8; \
                      }while(0)
                              
              #elif  (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 134          
 135              /**
 136               * @brief     ä¸²å£ç”¨å®šæ—¶å™¨2åšæ³¢ç‰¹ç‡å‘ç”Ÿå™¨è®¡ç®—æ³¢ç‰¹ç‡å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°ƒ
             -ç”¨ã€‚
 137               * @details   Serial port uses timer 2 to do baud rate generator calculation baud rate macro function,
             - 
 138               *            which is only called in this file.
 139               * @param[in] brtMode  æ³¢ç‰¹ç‡å‘ç”Ÿå™¨æ¨¡å¼ã€‚Baud rate generator mode.
 140               * @param[in] baudRate æ³¢ç‰¹ç‡ã€‚Baud rate.
 141              **/ 
 142                  #define uartx_TIMER2_BRTMODE_CFG(brtMode,baudRate)                                                      \
 143              do{                                                                                                   
             -  \
 144                      AUXR = (AUXR & 0xFB) | ( !brtMode << 2 );                                                           \
 145                      T2L = (65536UL - (sysClk_FRE / (TM2PS + 1) ) / (baudRate * 4 * (11 * (!(AUXR & 0x04)) + 1 )));      \
 146                      T2H = (65536UL - (sysClk_FRE / (TM2PS + 1) ) / (baudRate * 4 * (11 * (!(AUXR & 0x04)) + 1 ))) >> 8; \
 147                  }while(0)
 148          
 149          
 150              /**
 151               * @brief     ä¸²å£3ç”¨å®šæ—¶å™¨3åšæ³¢ç‰¹ç‡å‘ç”Ÿå™¨è®¡ç®—æ³¢ç‰¹ç‡å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°
             -ƒç”¨ã€‚
 152               * @details   Serial port 3 uses timer 3 to do baud rate generator calculation baud rate macro functio
             -n, 
 153               *            which is only called in this file.
 154               * @param[in] brtMode  æ³¢ç‰¹ç‡å‘ç”Ÿå™¨æ¨¡å¼ã€‚Baud rate generator mode.
 155               * @param[in] baudRate æ³¢ç‰¹ç‡ã€‚Baud rate.
 156              **/
 157                  #define UART3_TIMER3_BRTMODE_CFG(brtMode,baudRate)                                                       
             -\
 158              do{                                                                                                   
             -   \
 159                      T4T3M = (T4T3M & 0xFD) | ( !brtMode << 1 );                                                          
             -\
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 4   

 160                      T3L = (65536UL - (sysClk_FRE / (TM3PS + 1) ) / (baudRate * 4 * (11 * (!(T4T3M & 0x02)) + 1 )));      
             -\
 161                      T3H = (65536UL - (sysClk_FRE / (TM3PS + 1) ) / (baudRate * 4 * (11 * (!(T4T3M & 0x02)) + 1 ))) >> 8; 
             -\
 162                  }while(0)
 163          
 164          
 165              /**
 166               * @brief     ä¸²å£4ç”¨å®šæ—¶å™¨4åšæ³¢ç‰¹ç‡å‘ç”Ÿå™¨è®¡ç®—æ³¢ç‰¹ç‡å®å‡½æ•°ï¼Œä»…é™æœ¬æ–‡ä»¶å†…è°
             -ƒç”¨ã€‚
 167               * @details   Serial port 4 uses timer 4 to do baud rate generator calculation baud rate macro functio
             -n, 
 168               *            which is only called in this file.
 169               * @param[in] brtMode  æ³¢ç‰¹ç‡å‘ç”Ÿå™¨æ¨¡å¼ã€‚Baud rate generator mode.
 170               * @param[in] baudRate æ³¢ç‰¹ç‡ã€‚Baud rate.
 171              **/
 172                  #define UART4_TIMER4_BRTMODE_CFG(brtMode,baudRate)                                                       
             - \
 173              do{                                                                                                   
             -    \
 174                      T4T3M = (T4T3M & 0xDF) | ( !brtMode << 5 );                                                          
             - \
 175                      T4L = (65536UL - (sysClk_FRE / (TM4PS + 1) ) / (baudRate * 4 * (11 * (!(T4T3M & 0x20)) + 1 )));      
             - \
 176                      T4H = (65536UL - (sysClk_FRE / (TM4PS + 1) ) / (baudRate * 4 * (11 * (!(T4T3M & 0x20)) + 1 ))) >> 8; 
             - \
 177                  }while(0)
 178                          
 179          #endif
 180          
 181          /*-----------------------------------------------------------------------
 182          |                                 DATA                                  |
 183          -----------------------------------------------------------------------*/
 184          #if ( PER_LIB_UART_CTRL == 1)
 185          
 186          /**
 187           * @brief   ä¸²å£å¿™æ ‡å¿—ä½ï¼Œè¿™æ˜¯ELLåº“è‡ªå®šä¹‰ä»é˜²æ­¢å¤šä¸²å£å†²çªçš„å˜é‡ã€‚
 188           * @details Serial port busy flag, this is a variable customized 
 189           *          by the ELL library to prevent multiple serial port conflicts.
 190          **/
 191          uint8_t UART_BUSY_FLAG = 0; //Busy flag of receive
 192          
 193          /*-----------------------------------------------------------------------
 194          |                               FUNCTION                                |
 195          -----------------------------------------------------------------------*/
 196          
 197                  #if (PER_LIB_UART_INIT_CTRL == 1)
 198                  
 199                          /**
 200                           * @brief     ä¸²å£1åˆå§‹åŒ–å‡½æ•°ã€‚ 
 201                           * @details   UART1 peripheral init function. 
 202                           * @param[in] uartx  ä¸²å£åˆå§‹åŒ–ç»“æ„ä½“å¥æŸ„ï¼Œåˆå§‹åŒ–æ—¶è¯·å®šä¹‰è¯¥å¥æŸ„ï¼Œå¹¶å°†å…¶åœ°å€ä¼
             - å‚ã€‚
 203                           *                    The uart initializes the structure handle. When initializing, 
 204                           *                    please define the handle and pass its address to the parameter.
 205                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 206                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 207                          **/
 208                          FSCSTATE UART1_Init(const UART_InitType* uartx)
 209                          {
 210   1                              extern uint32_t Get_SysClk_FRE(void);
 211   1                              uint32_t sysClk_FRE;
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 5   

 212   1                                /* Get system clock frequency */
 213   1                              sysClk_FRE = Get_SysClk_FRE();
 214   1                              UART1_MODE_CFG(uartx -> Mode);
 215   1                              switch(uartx -> BRTGen)
 216   1                              {
 217   2                                case UART_BRT_TIM1:
 218   2                                {
 219   3                                      TR1 = 0;        //Turn off timer0
 220   3                                      ET1 = 0;        //Ban timer0 interrupt
 221   3                                      AUXR &= 0xFE;   //Select timer 1 as baud rate generator
 222   3                                      TMOD &= 0x0F;   //Timer 1 is fixed to 16 bit auto reload mode
 223   3                                      UART1_TIMER1_BRTMODE_CFG(uartx -> BRTMode,
 224   3                                                                                 uartx -> BaudRate);
 225   3                                      TR1 = 1;        //Turn on timer0
 226   3                                      break;
 227   3                                }
 228   2                                case UART_BRT_TIM2:
 229   2                                {
 230   3                                      AUXR &= 0xEF;  //Turn off timer2
 231   3                                      IE2 &= 0xFB;   //Ban timer2 interrupt
 232   3                                      AUXR |= 0x01;  //Select timer2 as baud rate generator
 233   3                                        
 234   3                                      #if (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
                                                
                                                      uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate); 
                                                
                                              #elif  (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 239   3                                        
 240   3                                              EAXFR_ENABLE();
 241   3                                              TM2PS = uartx -> BRTGenClkDiv;
 242   3                                              uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate);     
 243   3                                              EAXFR_DISABLE();
 244   3                                        
 245   3                                      #endif  
 246   3                        
 247   3                                      AUXR |= 0X10;  //Turn on timer2
 248   3                                      break;
 249   3                                }
 250   2                                default: return FSC_FAIL;
 251   2                              }
 252   1                              
 253   1                              AUXR = (AUXR & 0xDF) | (uartx -> BRTDouble << 5);
 254   1                              SCON = (SCON & 0xDF) | (uartx -> MulitComm << 5);
 255   1                              SCON = (SCON & 0xEF) | (uartx -> RxEnable << 4);
 256   1                              AUXR2 = (AUXR2 & 0xEF) | (uartx -> Relay << 4);
 257   1                              UART1_CLEAR_BUSY_FLAG();
 258   1                              
 259   1                              return FSC_SUCCESS;
 260   1                      }
 261          
 262          
 263                          /**
 264                           * @brief     ä¸²å£2åˆå§‹åŒ–å‡½æ•°ã€‚ 
 265                           * @details   UART2 peripheral init function. 
 266                           * @param[in] uartx  ä¸²å£åˆå§‹åŒ–ç»“æ„ä½“å¥æŸ„ï¼Œåˆå§‹åŒ–æ—¶è¯·å®šä¹‰è¯¥å¥æŸ„ï¼Œå¹¶å°†å…¶åœ°å€ä¼
             - å‚ã€‚
 267                           *                    The uart initializes the structure handle. When initializing, 
 268                           *                    please define the handle and pass its address to the parameter.
 269                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 270                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 271                          **/
 272                          FSCSTATE UART2_Init(const UART_InitType* uartx)
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 6   

 273                          {
 274   1                              extern uint32_t Get_SysClk_FRE(void);
 275   1                              uint32_t sysClk_FRE;
 276   1                              /* Get system clock frequency */
 277   1                              sysClk_FRE = Get_SysClk_FRE();
 278   1                              UART2_MODE_CFG(uartx -> Mode);
 279   1                              if(uartx -> BRTGen == UART_BRT_TIM2)
 280   1                              {
 281   2                                      AUXR &= 0xEF;  //Turn off timer2
 282   2                                      IE2 &= 0xFB;   //Ban timer2 interrupt
 283   2                                      
 284   2                                      #if (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
                                                
                                                      uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate); 
                                                
                                              #elif  (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 289   2                                        
 290   2                                              EAXFR_ENABLE();
 291   2                                              TM2PS = uartx -> BRTGenClkDiv;
 292   2                                              uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate);     
 293   2                                              EAXFR_DISABLE();
 294   2                                        
 295   2                                      #endif  
 296   2                        
 297   2                                      AUXR |= 0X10;  //Turn on timer2
 298   2                              }
 299   1                              else return FSC_FAIL;
 300   1                              S2CON = (S2CON & 0xDF) | (uartx -> MulitComm << 5);
 301   1                              S2CON = (S2CON & 0xEF) | (uartx -> RxEnable << 4);
 302   1                              UART2_CLEAR_BUSY_FLAG();
 303   1                              return FSC_SUCCESS;
 304   1                      }
 305          
 306          
 307                          /**
 308                           * @brief     ä¸²å£3åˆå§‹åŒ–å‡½æ•°ã€‚ 
 309                           * @details   UART3 peripheral init function. 
 310                           * @param[in] uartx  ä¸²å£åˆå§‹åŒ–ç»“æ„ä½“å¥æŸ„ï¼Œåˆå§‹åŒ–æ—¶è¯·å®šä¹‰è¯¥å¥æŸ„ï¼Œå¹¶å°†å…¶åœ°å€ä¼
             - å‚ã€‚
 311                           *                    The uart initializes the structure handle. When initializing, 
 312                           *                    please define the handle and pass its address to the parameter.
 313                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 314                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 315                          **/
 316                          FSCSTATE UART3_Init(const UART_InitType* uartx)
 317                          {
 318   1                              extern uint32_t Get_SysClk_FRE(void);
 319   1                              uint32_t sysClk_FRE;
 320   1                              /* Get system clock frequency */
 321   1                              sysClk_FRE = Get_SysClk_FRE();
 322   1                              UART3_MODE_CFG(uartx -> Mode);
 323   1                              switch(uartx -> BRTGen)
 324   1                              {
 325   2                                      case UART_BRT_TIM2:
 326   2                                      {
 327   3                                              AUXR &= 0xEF;  //Turn off timer2
 328   3                                              IE2 &= 0xFB;   //Ban timer2 interrupt
 329   3                                              S3CON &= 0xBF;  //Select timer2 as baud rate generator
 330   3                                              
 331   3                                              #if (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
                                                        
                                                              uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate); 
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 7   

                                                        
                                                      #elif  (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 336   3                                                
 337   3                                                      EAXFR_ENABLE();
 338   3                                                      TM2PS = uartx -> BRTGenClkDiv;
 339   3                                                      uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate);     
 340   3                                                      EAXFR_DISABLE();
 341   3                                                
 342   3                                              #endif  
 343   3                        
 344   3                                              AUXR |= 0X10;  //Turn on timer2
 345   3                                              break;
 346   3                                      }
 347   2                                      case UART_BRT_TIM3:
 348   2                                      {
 349   3                                              T4T3M &= 0xF7;  //Turn off timer3
 350   3                                              IE2 &= 0xDF;  //Ban timer3 interrupt
 351   3                                              S3CON |= 0x40;    //Select timer3 as baud rate generator
 352   3                                              
 353   3                                              #if (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
                                                        
                                                              UART3_TIMER3_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate); 
                                                        
                                                      #elif  (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 358   3                                                
 359   3                                                      EAXFR_ENABLE();
 360   3                                                      TM3PS = uartx -> BRTGenClkDiv;
 361   3                                                      UART3_TIMER3_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate);     
 362   3                                                      EAXFR_DISABLE();
 363   3                                                
 364   3                                              #endif  
 365   3                        
 366   3                                              T4T3M |= 0x08; //Turn on timer3 
 367   3                                              break;
 368   3                                       }
 369   2                                       default: return FSC_FAIL;
 370   2                              }
 371   1                              S3CON = (S3CON & 0xDF) | (uartx -> MulitComm << 5);
 372   1                              S3CON = (S3CON & 0xEF) | (uartx -> RxEnable << 4);
 373   1                              UART3_CLEAR_BUSY_FLAG();
 374   1                              return FSC_SUCCESS;
 375   1                      }
 376          
 377          
 378                          /**
 379                           * @brief     ä¸²å£4åˆå§‹åŒ–å‡½æ•°ã€‚ 
 380                           * @details   UART4 peripheral init function. 
 381                           * @param[in] uartx  ä¸²å£åˆå§‹åŒ–ç»“æ„ä½“å¥æŸ„ï¼Œåˆå§‹åŒ–æ—¶è¯·å®šä¹‰è¯¥å¥æŸ„ï¼Œå¹¶å°†å…¶åœ°å€ä¼
             - å‚ã€‚
 382                           *                    The uart initializes the structure handle. When initializing, 
 383                           *                    please define the handle and pass its address to the parameter.
 384                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 385                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 386                          **/
 387                          FSCSTATE UART4_Init(const UART_InitType* uartx)
 388                          {
 389   1                              extern uint32_t Get_SysClk_FRE(void);
 390   1                              uint32_t sysClk_FRE;
 391   1                              /* Get system clock frequency */
 392   1                              sysClk_FRE = Get_SysClk_FRE();
 393   1                              UART4_MODE_CFG(uartx -> Mode);
 394   1                              switch(uartx -> BRTGen)
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 8   

 395   1                              {
 396   2                                      case UART_BRT_TIM2:
 397   2                                      {
 398   3                                              AUXR &= 0xEF;  //Turn off timer2
 399   3                                              IE2 &= 0xFB;   //Ban timer2 interrupt
 400   3                                              S4CON &= 0xBF;  //Select timer2 as baud rate generator
 401   3                                              
 402   3                                              #if (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
                                                        
                                                              uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate); 
                                                        
                                                      #elif  (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 407   3                                                
 408   3                                                      EAXFR_ENABLE();
 409   3                                                      TM2PS = uartx -> BRTGenClkDiv;
 410   3                                                      uartx_TIMER2_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate);     
 411   3                                                      EAXFR_DISABLE();
 412   3                                                
 413   3                                              #endif  
 414   3                        
 415   3                                              AUXR |= 0X10;  //Turn on timer2
 416   3                                              break;
 417   3                                      }
 418   2                                      case UART_BRT_TIM4:
 419   2                                      {
 420   3                                              T4T3M &= 0x7F;  //Turn off timer3
 421   3                                              IE2 &= 0xBF;  //Ban timer4 interrupt
 422   3                                              S4CON |= 0x40;   //Select timer3 as baud rate generator
 423   3                                              
 424   3                                              #if (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
                                                        
                                                              UART4_TIMER4_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate); 
                                                        
                                                      #elif  (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 429   3                                                
 430   3                                                      EAXFR_ENABLE();
 431   3                                                      TM4PS = uartx -> BRTGenClkDiv;
 432   3                                                      UART4_TIMER4_BRTMODE_CFG(uartx -> BRTMode,uartx -> BaudRate);     
 433   3                                                      EAXFR_DISABLE();
 434   3                                                
 435   3                                              #endif  
 436   3                        
 437   3                                              T4T3M |= 0x80; //Turn on timer4
 438   3                                              break;
 439   3                                      } 
 440   2                                      default: return FSC_FAIL;
 441   2                               }
 442   1                              S4CON = (S4CON & 0xDF) | (uartx -> MulitComm << 5);
 443   1                              S4CON = (S4CON & 0xEF) | (uartx -> RxEnable << 4);
 444   1                              UART4_CLEAR_BUSY_FLAG();
 445   1                              return FSC_SUCCESS;
 446   1                      }
 447          
 448                  #endif
 449                          
 450                  #if (PER_LIB_UART_NVIC_CTRL == 1)
 451          
 452                          /**
 453                           * @brief     ä¸²å£1ä¸­æ–­åˆå§‹åŒ–å‡½æ•°ã€‚
 454                           * @details   UART1 NVIC function.
 455                           * @param[in] pri ä¸­æ–­ä¼˜å…ˆçº§ã€‚interrupt pri.
 456                           * @param[in] run ä½¿èƒ½æ§åˆ¶ä½ã€‚enable control. 
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 9   

 457                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 458                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 459                          **/
 460                          FSCSTATE NVIC_UART1_Init(NVICPri_Type pri,BOOL run)
 461                          {
 462   1                              ES = run;
 463   1                              NVIC_UART1_PRI(pri); 
 464   1                              return FSC_SUCCESS;
 465   1                      }
 466          
 467          
 468                          /**
 469                           * @brief     ä¸²å£2ä¸­æ–­åˆå§‹åŒ–å‡½æ•°ã€‚
 470                           * @details   UART2 NVIC function.
 471                           * @param[in] pri ä¸­æ–­ä¼˜å…ˆçº§ã€‚interrupt pri.
 472                           * @param[in] run ä½¿èƒ½æ§åˆ¶ä½ã€‚enable control. 
 473                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 474                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 475                          **/
 476                          FSCSTATE NVIC_UART2_Init(NVICPri_Type pri,BOOL run)
 477                          {
 478   1                              IE2 = (IE2 & 0xFE) | (run);
 479   1                              NVIC_UART2_PRI(pri);
 480   1                              return FSC_SUCCESS;
 481   1                      }
 482          
 483          
 484                          #if (PER_LIB_MCU_MUODEL == STC8Ax || PER_LIB_MCU_MUODEL == STC8Fx)
              
                              /**
                               * @brief     ä¸²å£3ä¸­æ–­åˆå§‹åŒ–å‡½æ•°ã€‚
                               * @details   UART3 NVIC function.
                               * @param[in] run ä½¿èƒ½æ§åˆ¶ä½ã€‚enable control. 
                               * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
                               * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
                              **/
                              FSCSTATE NVIC_UART3_Init(BOOL run)
                              {
                                      IE2 = (IE2 & 0xF7) | (run << 3);
                                      return FSC_SUCCESS;
                              }
              
              
                              /**
                               * @brief     ä¸²å£4ä¸­æ–­åˆå§‹åŒ–å‡½æ•°ã€‚
                               * @details   UART4 NVIC function.
                               * @param[in] run ä½¿èƒ½æ§åˆ¶ä½ã€‚enable control. 
                               * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
                               * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
                              **/
                              FSCSTATE NVIC_UART4_Init(BOOL run)
                              {
                                      IE2 = (IE2 & 0xEF) | (run << 4);
                                      return FSC_SUCCESS;
                              }
              
              
                              #elif (PER_LIB_MCU_MUODEL == STC8Cx || PER_LIB_MCU_MUODEL == STC8Gx || PER_LIB_MCU_MUODEL == STC8Hx)
 515          
 516                                  /**
 517                                   * @brief     ä¸²å£3ä¸­æ–­åˆå§‹åŒ–å‡½æ•°ã€‚
 518                                   * @details   UART3 NVIC function.
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 10  

 519                                   * @param[in] pri ä¸­æ–­ä¼˜å…ˆçº§ã€‚interrupt pri.
 520                                   * @param[in] run ä½¿èƒ½æ§åˆ¶ä½ã€‚enable control. 
 521                                   * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 522                                   * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 523                                  **/
 524                                  FSCSTATE NVIC_UART3_Init(NVICPri_Type pri,BOOL run)
 525                                  {
 526   1                                      IE2 = (IE2 & 0xF7) | (run << 3);
 527   1                                      NVIC_UART3_PRI(pri);
 528   1                                      return FSC_SUCCESS;
 529   1                              }
 530          
 531                                  /**
 532                                   * @brief     ä¸²å£4ä¸­æ–­åˆå§‹åŒ–å‡½æ•°ã€‚
 533                                   * @details   UART4 NVIC function.
 534                                   * @param[in] pri ä¸­æ–­ä¼˜å…ˆçº§ã€‚interrupt pri.
 535                                   * @param[in] run ä½¿èƒ½æ§åˆ¶ä½ã€‚enable control. 
 536                                   * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 537                                   * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 538                                  **/
 539                                  FSCSTATE NVIC_UART4_Init(NVICPri_Type pri,BOOL run)
 540                                  {
 541   1                                      IE2 = (IE2 & 0xEF) | (run << 4);
 542   1                                      NVIC_UART4_PRI(pri);
 543   1                                      return FSC_SUCCESS;
 544   1                              }
 545          
 546                          #endif
 547          
 548                  #endif
 549          
 550                  #if (PER_LIB_UART_WORK_CTRL == 1)
 551                                  
 552                          /**
 553                           * @brief     ä¸²å£1åˆ‡æ¢å¤ç”¨IOå‡½æ•°ã€‚
 554                           * @details   UART1 switch out port control function.  
 555                           * @param[in] port å¤ç”¨IOæšä¸¾ä½“ã€‚IO switch enumerator.
 556                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 557                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 558                          **/
 559                          FSCSTATE GPIO_UART1_SWPort(GPIOSWPort_Type port)
 560                          {
 561   1                              P_SW1 = (P_SW1 & 0x3F) | (port << 6);
 562   1                              return FSC_SUCCESS;
 563   1                      }
 564          
 565          
 566                          /**
 567                           * @brief     ä¸²å£2åˆ‡æ¢å¤ç”¨IOå‡½æ•°ã€‚
 568                           * @details   UART2 switch out port control function.  
 569                           * @param[in] port å¤ç”¨IOæšä¸¾ä½“ã€‚IO switch enumerator.
 570                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 571                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 572                          **/
 573                          FSCSTATE GPIO_UART2_SWPort(GPIOSWPort_Type port)
 574                          {
 575   1                              if(port < SW_Port3)
 576   1                              {
 577   2                                      P_SW2 = (P_SW2 & 0xFE) | (port);
 578   2                                      return FSC_SUCCESS;
 579   2                              }
 580   1                              else return FSC_FAIL;
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 11  

 581   1                      }
 582          
 583          
 584                          /**
 585                           * @brief     ä¸²å£3åˆ‡æ¢å¤ç”¨IOå‡½æ•°ã€‚
 586                           * @details   UART3 switch out port control function.  
 587                           * @param[in] port å¤ç”¨IOæšä¸¾ä½“ã€‚IO switch enumerator.
 588                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 589                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 590                          **/
 591                          FSCSTATE GPIO_UART3_SWPort(GPIOSWPort_Type port)
 592                          {
 593   1                              if(port < SW_Port3)
 594   1                              {
 595   2                                      P_SW2 = (P_SW2 & 0xFD) | (port << 1);
 596   2                                      return FSC_SUCCESS;
 597   2                              }
 598   1                              else return FSC_FAIL;
 599   1                      }
 600          
 601          
 602                          /**
 603                           * @brief     ä¸²å£4åˆ‡æ¢å¤ç”¨IOå‡½æ•°ã€‚
 604                           * @details   UART4 switch out port control function.  
 605                           * @param[in] port å¤ç”¨IOæšä¸¾ä½“ã€‚IO switch enumerator.
 606                           * @return    FSC_SUCCESS è¿”å›æˆåŠŸã€‚Return to success.
 607                           * @return    FSC_FAIL    è¿”å›å¤±è´¥ã€‚Return to fail.
 608                          **/
 609                          FSCSTATE GPIO_UART4_SWPort(GPIOSWPort_Type port)
 610                          {
 611   1                              if(port < SW_Port3)
 612   1                              {
 613   2                                      P_SW2 = (P_SW2 & 0xFB) | (port << 2);
 614   2                                      return FSC_SUCCESS;
 615   2                              }
 616   1                              else return FSC_FAIL;
 617   1                      }
 618          
 619          
 620                          /**
 621                           * @brief      ä¸²å£1å‘é€ä¸€ä¸ªå­—èŠ‚å‡½æ•°ï¼Œ
 622                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 623                           * @details    Serial port 1 sends a byte function,
 624                           *             Need to turn on the interrupt and clear the sending flag,
 625                           *             in the interrupt service function.
 626                           * @param[in]  dat è¦å‘é€çš„å­—èŠ‚æ•°æ®ã€‚The byte data to be sent.
 627                           * @return     None. 
 628                          **/
 629                          void UART1_Isr_Send_Byte(uint8_t dat)
 630                          {
 631   1                              while(UART1_GET_BUSY_FLAG());
 632   1                              UART1_SET_BUSY_FLAG();
 633   1                              SBUF = dat;
 634   1                      }
 635          
 636          
 637                          /**
 638                           * @brief      ä¸²å£2å‘é€ä¸€ä¸ªå­—èŠ‚å‡½æ•°ï¼Œ
 639                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 640                           * @details    Serial port 2 sends a byte function,
 641                           *             Need to turn on the interrupt and clear the sending flag,
 642                           *             in the interrupt service function.
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 12  

 643                           * @param[in]  dat è¦å‘é€çš„å­—èŠ‚æ•°æ®ã€‚The byte data to be sent.
 644                           * @return     None. 
 645                          **/
 646                          void UART2_Isr_Send_Byte(uint8_t dat)
 647                          {
 648   1                              while(UART2_GET_BUSY_FLAG());
 649   1                              UART2_SET_BUSY_FLAG();
 650   1                              S2BUF = dat;
 651   1                      }
 652          
 653          
 654                          /**
 655                           * @brief      ä¸²å£3å‘é€ä¸€ä¸ªå­—èŠ‚å‡½æ•°ï¼Œ
 656                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 657                           * @details    Serial port 3 sends a byte function,
 658                           *             Need to turn on the interrupt and clear the sending flag,
 659                           *             in the interrupt service function.
 660                           * @param[in]  dat è¦å‘é€çš„å­—èŠ‚æ•°æ®ã€‚The byte data to be sent.
 661                           * @return     None. 
 662                          **/
 663                          void UART3_Isr_Send_Byte(uint8_t dat)
 664                          {
 665   1                              while(UART3_GET_BUSY_FLAG());
 666   1                              UART3_SET_BUSY_FLAG();
 667   1                              S3BUF = dat;
 668   1                      }
 669          
 670          
 671                          /**
 672                           * @brief      ä¸²å£4å‘é€ä¸€ä¸ªå­—èŠ‚å‡½æ•°ï¼Œ
 673                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 674                           * @details    Serial port 4 sends a byte function,
 675                           *             Need to turn on the interrupt and clear the sending flag,
 676                           *             in the interrupt service function.
 677                           * @param[in]  dat è¦å‘é€çš„å­—èŠ‚æ•°æ®ã€‚The byte data to be sent.
 678                           * @return     None. 
 679                          **/
 680                          void UART4_Isr_Send_Byte(uint8_t dat)
 681                          {
 682   1                              while(UART4_GET_BUSY_FLAG());
 683   1                              UART4_SET_BUSY_FLAG();
 684   1                              S4BUF = dat;
 685   1                      }
 686                  
 687          
 688                          /**
 689                           * @brief      ä¸²å£1å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²å‡½æ•°ï¼Œ
 690                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 691                           * @details    Serial port 1 sends a string function,
 692                           *             Need to turn on the interrupt and clear the sending flag,
 693                           *             in the interrupt service function.
 694                           * @param[in]  str è¦å‘é€çš„å­—ç¬¦ä¸²åœ°å€ã€‚String address to be sent.
 695                           * @return     None. 
 696                          **/
 697                          void UART1_Isr_Send_String(const uint8_t *str)
 698                          {
 699   1                              while(*str != '\0')
 700   1                              {
 701   2                                      UART1_Isr_Send_Byte(*(str++));
 702   2                              }
 703   1                      }
 704          
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 13  

 705          
 706                          /**
 707                           * @brief      ä¸²å£2å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²å‡½æ•°ï¼Œ
 708                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 709                           * @details    Serial port 2 sends a string function,
 710                           *             Need to turn on the interrupt and clear the sending flag,
 711                           *             in the interrupt service function.
 712                           * @param[in]  str è¦å‘é€çš„å­—ç¬¦ä¸²åœ°å€ã€‚String address to be sent.
 713                           * @return     None. 
 714                          **/
 715                          void UART2_Isr_Send_String(const uint8_t *str)
 716                          {
 717   1                              while(*str != '\0')
 718   1                              {
 719   2                                      UART2_Isr_Send_Byte(*(str++));
 720   2                              }
 721   1                      }
 722          
 723          
 724                          /**
 725                           * @brief      ä¸²å£3å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²å‡½æ•°ï¼Œ
 726                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 727                           * @details    Serial port 3 sends a string function,
 728                           *             Need to turn on the interrupt and clear the sending flag,
 729                           *             in the interrupt service function.
 730                           * @param[in]  str è¦å‘é€çš„å­—ç¬¦ä¸²åœ°å€ã€‚String address to be sent.
 731                           * @return     None. 
 732                          **/
 733                          void UART3_Isr_Send_String(const uint8_t* str)
 734                          {
 735   1                              while(*str != '\0')
 736   1                              {
 737   2                                      UART3_Isr_Send_Byte(*(str++));
 738   2                              }
 739   1                      }
 740          
 741          
 742                          /**
 743                           * @brief      ä¸²å£4å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²å‡½æ•°ï¼Œ
 744                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 745                           * @details    Serial port 4 sends a string function,
 746                           *             Need to turn on the interrupt and clear the sending flag,
 747                           *             in the interrupt service function.
 748                           * @param[in]  str è¦å‘é€çš„å­—ç¬¦ä¸²åœ°å€ã€‚String address to be sent.
 749                           * @return     None. 
 750                          **/
 751                          void UART4_Isr_Send_String(const uint8_t *str)
 752                          {
 753   1                              while(*str != '\0')
 754   1                              {
 755   2                                      UART4_Isr_Send_Byte(*(str++));
 756   2                              }
 757   1                      }
 758          
 759          
 760                          /**
 761                           * @brief      ä¸²å£1å‘é€ä¸€ä¸ªæ•°ç»„å‡½æ•°ï¼Œ
 762                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 763                           * @details    Serial port 1 sends a arry function,
 764                           *             Need to turn on the interrupt and clear the sending flag,
 765                           *             in the interrupt service function.
 766                           * @param[in]  arry è¦å‘é€çš„æ•°ç»„åœ°å€ã€‚The address of the array to be sent.
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 14  

 767                           * @param[in]  len  è¦å‘é€çš„æ•°ç»„é•¿åº¦ã€‚The length of the array to be sent.
 768                           * @return     None. 
 769                          **/
 770                          void UART1_Isr_Send_Array(const uint8_t *arry,uint16_t len)
 771                          {
 772   1                              while(len--)
 773   1                              {
 774   2                                      UART1_Isr_Send_Byte(*(arry++));
 775   2                              }
 776   1                      }
 777          
 778          
 779                          /**
 780                           * @brief      ä¸²å£2å‘é€ä¸€ä¸ªæ•°ç»„å‡½æ•°ï¼Œ
 781                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 782                           * @details    Serial port 2 sends a arry function,
 783                           *             Need to turn on the interrupt and clear the sending flag,
 784                           *             in the interrupt service function.
 785                           * @param[in]  arry è¦å‘é€çš„æ•°ç»„åœ°å€ã€‚The address of the array to be sent.
 786                           * @param[in]  len  è¦å‘é€çš„æ•°ç»„é•¿åº¦ã€‚The length of the array to be sent.
 787                           * @return     None. 
 788                          **/
 789                          void UART2_Isr_Send_Array(const uint8_t *arry,uint16_t len)
 790                          {
 791   1                              while(len--)
 792   1                              {
 793   2                                      UART2_Isr_Send_Byte(*(arry++));
 794   2                              }
 795   1                      }
 796          
 797          
 798                          /**
 799                           * @brief      ä¸²å£3å‘é€ä¸€ä¸ªæ•°ç»„å‡½æ•°ï¼Œ
 800                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 801                           * @details    Serial port 3 sends a arry function,
 802                           *             Need to turn on the interrupt and clear the sending flag,
 803                           *             in the interrupt service function.
 804                           * @param[in]  arry è¦å‘é€çš„æ•°ç»„åœ°å€ã€‚The address of the array to be sent.
 805                           * @param[in]  len  è¦å‘é€çš„æ•°ç»„é•¿åº¦ã€‚The length of the array to be sent.
 806                           * @return     None. 
 807                          **/
 808                          void UART3_Isr_Send_Array(const uint8_t *arry,uint16_t len)
 809                          {
 810   1                              while(len--)
 811   1                              {
 812   2                                      UART3_Isr_Send_Byte(*(arry++));
 813   2                              }
 814   1                      }
 815          
 816          
 817                          /**
 818                           * @brief      ä¸²å£4å‘é€ä¸€ä¸ªæ•°ç»„å‡½æ•°ï¼Œ
 819                           *             éœ€è¦å¼€å¯ä¸­æ–­ï¼Œå¹¶åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­æ¸…é™¤å‘é€æ ‡å¿—ä½ã€‚
 820                           * @details    Serial port 4 sends a arry function,
 821                           *             Need to turn on the interrupt and clear the sending flag,
 822                           *             in the interrupt service function.
 823                           * @param[in]  arry è¦å‘é€çš„æ•°ç»„åœ°å€ã€‚The address of the array to be sent.
 824                           * @param[in]  len  è¦å‘é€çš„æ•°ç»„é•¿åº¦ã€‚The length of the array to be sent.
 825                           * @return     None. 
 826                          **/
 827                          void UART4_Isr_Send_Array(const uint8_t *arry,uint16_t len)
 828                          {
C51 COMPILER V9.01   STC8X_UART                                                            08/04/2021 11:57:18 PAGE 15  

 829   1                              while(len--)
 830   1                              {
 831   2                                      UART4_Isr_Send_Byte(*(arry++));
 832   2                              }
 833   1                      }
 834                          
 835                  #endif
 836                          
 837          #endif
 838          /*-----------------------------------------------------------------------
 839          |                   END OF FLIE.  (C) COPYRIGHT zeweni                  |
 840          -----------------------------------------------------------------------*/
 841          
 842          
 843          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2315    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      60
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
